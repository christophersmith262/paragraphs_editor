<?php

namespace Drupal\paragraphs_editor\Plugin\Field\FieldWidget;

use Drupal\Component\Plugin\PluginManagerInterface;
use Drupal\Core\Entity\EntityDisplayRepositoryInterface;
use Drupal\Core\Entity\RevisionableInterface;
use Drupal\Core\Entity\EntityFormInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Field\FieldItemListInterface;
use Drupal\Core\Field\WidgetBase;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
use Drupal\dom_processor\DomProcessor\DomProcessorInterface;
use Drupal\paragraphs_editor\ParagraphsEditorFormInterface;
use Drupal\paragraphs_editor\Utility\TypeUtility;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * Plugin implementation of the 'entity_reference_paragraphs_editor' widget.
 *
 * @FieldWidget(
 *   id = "entity_reference_paragraphs_editor",
 *   label = @Translation("Paragraphs Editor"),
 *   multiple_values = TRUE,
 *   description = @Translation("Editor paragraphs form widget."),
 *   field_types = {
 *     "entity_reference_revisions"
 *   }
 * )
 */
class ParagraphsEditorWidget extends WidgetBase implements ContainerFactoryPluginInterface {

  /**
   * The dom processor for preparing and extracting editor content.
   *
   * @var \Drupal\dom_processor\DomProcessor\DomProcessorInterface
   */
  protected $domProcessor;

  /**
   * The plugin manager for bundle selector plugins.
   *
   * @var \Drupal\Component\Plugin\PluginManagerInterface
   */
  protected $bundleSelectorManager;

  /**
   * The plugin manager for delivery plugins.
   *
   * @var \Drupal\Component\Plugin\PluginManagerInterface
   */
  protected $deliveryProviderManager;

  /**
   * The entity display repository service for getting view modes.
   *
   * @var \Drupal\Core\Entity\EntityDisplayRepositoryInterface
   */
  protected $entityDisplayRepository;

  /**
   * Creates a paragraphs editor field widget.
   *
   * @param string $plugin_id
   *   The field widget plugin id.
   * @param mixed $plugin_definition
   *   The plugin definition.
   * @param \Drupal\Core\Field\FieldDefinitionInterface $field_definition
   *   The paragraphs editor field definition.
   * @param array $settings
   *   The paragraphs editor field widget settings.
   * @param array $third_party_settings
   *   The third party settings for the widget.
   * @param \Drupal\dom_processor\DomProcessor\DomProcessorInterface $dom_processor
   *   The DOM processor for reading and writing markup.
   * @param \Drupal\Core\Entity\EntityDisplayRepositoryInterface $entity_display_repository
   *   The view mode manager.
   * @param \Drupal\Component\Plugin\PluginManagerInterface $bundle_selector_manager
   *   The bundle selector plugin manager service.
   * @param \Drupal\Component\Plugin\PluginManagerInterface $delivery_provider_manager
   *   The delivery provider plugin manager service.
   */
  public function __construct($plugin_id, $plugin_definition, FieldDefinitionInterface $field_definition, array $settings, array $third_party_settings, DomProcessorInterface $dom_processor, EntityDisplayRepositoryInterface $entity_display_repository, PluginManagerInterface $bundle_selector_manager, PluginManagerInterface $delivery_provider_manager) {
    parent::__construct($plugin_id, $plugin_definition, $field_definition, $settings, $third_party_settings);
    $this->domProcessor = $dom_processor;
    $this->entityDisplayRepository = $entity_display_repository;
    $this->bundleSelectorManager = $bundle_selector_manager;
    $this->deliveryProviderManager = $delivery_provider_manager;
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    return new static(
      $plugin_id,
      $plugin_definition,
      $configuration['field_definition'],
      $configuration['settings'],
      $configuration['third_party_settings'],
      $container->get('dom_processor.dom_processor'),
      $container->get('entity_display.repository'),
      $container->get('paragraphs_editor.bundle_selector.manager'),
      $container->get('paragraphs_editor.delivery_provider.manager')
    );
  }

  /**
   * {@inheritdoc}
   */
  public static function defaultSettings() {
    return [
      'title' => t('Paragraph'),
      'filter_format' => 'paragraphs_ckeditor',
      'bundle_selector' => 'list',
      'delivery_provider' => 'modal',
      'view_mode' => 'default',
      'prerender_count' => '10',
    ];
  }

  /**
   * {@inheritdoc}
   */
  public function formElement(FieldItemListInterface $items, $delta, array $element, array &$form, FormStateInterface $form_state) {
    if (!$this->shouldHide($items, $form_state)) {
      $editable_data = $this->process('load', $items, $form_state);

      // Pretty much all the important parts are generated by the DOM processor.
      // Offloading things like '#attached' and '#attributes' to the processor
      // allows it to do things like dynamically load javascript for rendered
      // entities.
      $element = [
        'markup' => $element + [
          '#type' => 'text_format',
          '#format' => $editable_data->get('filter_format'),
          '#default_value' => $editable_data->get('markup'),
          '#rows' => 100,
          '#attributes' => $editable_data->get('attributes'),
          '#attached' => [
            'library' => $editable_data->get('libraries'),
            'drupalSettings' => $editable_data->get('drupalSettings'),
          ],
          '#allowed_formats' => [$editable_data->get('filter_format')],
          '#value_callback' => self::CLASS . '::contextSensitiveValueCallback',
        ],
        'context_id' => [
          '#type' => 'hidden',
          '#default_value' => $editable_data->get('context_id'),
          '#value_callback' => self::CLASS . '::contextSenstiveValueCallback',
        ],
      ];

      $element['markup']['#attributes']['class'][] = 'js-text-full';
      $element['markup']['#attributes']['class'][] = 'text-full';
      $element['markup']['summary'] = [
        '#type' => 'textarea',
        '#default_value' => $items->entity->markup->summary,
        '#title' => $this->t('Summary'),
        '#rows' => 5,
        '#description' => $this->t('Leave blank to use trimmed value of full text as the summary.'),
        '#attached' => [
          'library' => ['text/drupal.text'],
        ],
        '#attributes' => ['class' => ['js-text-summary', 'text-summary']],
        '#prefix' => '<div class="js-text-summary-wrapper text-summary-wrapper">',
        '#suffix' => '</div>',
        '#weight' => -10,
        '#base_type' => 'text_format',
      ];
    }
    else {
      $element = [];
    }

    return $element;
  }

  /**
   * {@inheritdoc}
   */
  public function settingsForm(array $form, FormStateInterface $form_state) {
    $elements = [];

    $elements['title'] = [
      '#type' => 'textfield',
      '#title' => $this->t('Paragraph Title'),
      '#description' => $this->t('Label to appear as title on the button "Insert [title]". This label is translatable.'),
      '#default_value' => $this->getSetting('title'),
      '#required' => TRUE,
    ];

    $options = [];
    foreach (filter_formats() as $filter_format) {
      $options[$filter_format->id()] = $filter_format->label();
    }

    $elements['filter_format'] = [
      '#type' => 'select',
      '#title' => $this->t('Filter Format'),
      '#description' => $this->t('The filter format to use for the editor.'),
      '#options' => $options,
      '#default_value' => $this->getSetting('filter_format'),
    ];

    $options = [];
    foreach ($this->bundleSelectorManager->getDefinitions() as $plugin) {
      $options[$plugin['id']] = $plugin['title'];
    }

    $elements['bundle_selector'] = [
      '#type' => 'select',
      '#title' => $this->t('Bundle Selection Handler'),
      '#description' => $this->t('The bundle selector form plugin that will be used to allow users to insert paragraph items.'),
      '#options' => $options,
      '#default_value' => $this->getSetting('bundle_selector'),
      '#required' => TRUE,
    ];

    $options = [];
    foreach ($this->deliveryProviderManager->getDefinitions() as $plugin) {
      $options[$plugin['id']] = $plugin['title'];
    }

    $elements['delivery_provider'] = [
      '#type' => 'select',
      '#title' => $this->t('Delivery Handler'),
      '#description' => $this->t('The delivery plugin that controls the user experience for how forms are delivered.'),
      '#options' => $options,
      '#default_value' => $this->getSetting('delivery_provider'),
      '#required' => TRUE,
    ];

    $elements['view_mode'] = [
      '#type' => 'select',
      '#title' => 'Editor View Mode',
      '#description' => $this->t('The view mode that will be used to render embedded entities.'),
      '#options' => $this->entityDisplayRepository->getViewModeOptions('paragraph'),
      '#default_value' => $this->getSetting('view_mode'),
      '#required' => TRUE,
    ];

    $options = [0 => $this->t('None')];
    for ($i = 5; $i <= 50; $i += 5) {
      $options[$i] = $i;
    }
    $options[-1] = $this->t('All');
    $elements['prerender_count'] = [
      '#type' => 'select',
      '#title' => 'Maximum Pre-Render Items',
      '#description' => $this->t("The maximum number of embedded paragraphs to render before an editor is initialized. Additional entities will be rendered via ajax on demand, and won't be available to edit until their respective ajax calls finish."),
      '#options' => $options,
      '#default_value' => $this->getSetting('prerender_count'),
      '#required' => TRUE,
    ];

    return $elements;
  }

  /**
   * {@inheritdoc}
   */
  public function settingsSummary() {
    $bundle_selector = $this->bundleSelectorManager->getDefinition($this->getSetting('bundle_selector'));
    $delivery_provider = $this->deliveryProviderManager->getDefinition($this->getSetting('delivery_provider'));
    $prerender_count = $this->getSetting('prerender_count');
    if ($prerender_count == '-1') {
      $prerender_count = 'All';
    }
    elseif ($prerender_count == '0') {
      $prerender_count = 'None';
    }
    $summary = [];
    $summary[] = $this->t('Title: @title', ['@title' => $this->getSetting('title')]);
    $summary[] = $this->t('Filter Format: @filter_format', ['@filter_format' => $this->getSetting('filter_format')]);
    $summary[] = $this->t('Bundle Selector: @bundle_selector', ['@bundle_selector' => $bundle_selector['title']]);
    $summary[] = $this->t('Delivery Provider: @delivery_provider', ['@delivery_provider' => $delivery_provider['title']]);
    $summary[] = $this->t('View Mode: @mode', ['@mode' => $this->getSetting('view_mode')]);
    $summary[] = $this->t('Maximum Pre-Render Items: @prerender_count', ['@prerender_count' => $prerender_count]);
    return $summary;
  }

  /**
   * {@inheritdoc}
   */
  public function extractFormValues(FieldItemListInterface $items, array $form, FormStateInterface $form_state) {
    if (!$this->shouldHide($items, $form_state)) {
      $field_name = $this->getFieldConfig()->getName();
      $path = array_merge($form['#parents'], [$field_name]);
      $values = $form_state->getValue($path);
      $this->process('update', $items, $form_state, $values['markup']['format'], $values['markup']['value'], $values['context_id']);
    }
    else {
      $items->setValue([]);
    }
  }

  /**
   * {@inheritdoc}
   */
  public static function isApplicable(FieldDefinitionInterface $field_definition) {
    return TypeUtility::isParagraphsEditorField($field_definition);
  }

  /**
   * A value callback for widget form elements.
   *
   * @param array &$element
   *   The widget form element. This must have a #default_value set.
   * @param mixed $input
   *   The user submitted input.
   * @param \Drupal\Core\Form\FormStateInterface $form_state
   *   The form state for the form the widget belongs to.
   *
   * @return mixed
   *   The current value of the field, or NULL to use Drupal's native input
   *   handling.
   */
  public static function contextSensitiveValueCallback(array &$element, $input, FormStateInterface $form_state) {
    // Since the widget field value must be rebuilt each time the form is
    // submitted, and the attached settings and field value will be rebuilt in a
    // context-sensitive mannor, we only allow user entered data to get into the
    // form value if the widget is being validated. Validation will trigger the
    // value extraction from the form input, which will update the field items.
    // Subsequent element builds will regenerate the value for the field based
    // on the updated field items, and we want to use that value for the field
    // instead of the user entered values in order to match the context of the
    // form element values with its regenerated widget binder metadata.
    if ($form_state->isValidationComplete()) {
      return $element['#default_value'];
    }
  }

  /**
   * Passes markup through the paragraphs_editor DOM processor.
   *
   * @param string $variant
   *   The DOM Processor plugin variant to run:
   *     - 'load' is used to take saved markup and make it editable.
   *     - 'update' is used to take editor markup and make it saveable.
   * @param \Drupal\Core\Field\FieldItemListInterface $items
   *   The field items that will receive savable entities, or serve loadable
   *   entities. Note that neither of these operations perform entity saves.
   * @param \Drupal\Core\Form\FormStateInterface $form_state
   *   The form state for the form that the field widget belongs to.
   * @param string|null $format
   *   The default filter format name to apply to created text entities.
   * @param string|null $markup
   *   The markup to be processed. Defaults to the markup inside the text
   *   entity.
   * @param string|null $context_id
   *   The id of the root editing context to pull edits from.
   *
   * @see \Drupal\paragraphs_editor\Plugin\dom_processor\data_processor\ParagraphsEditorPreparer
   * @see \Drupal\paragraphs_editor\Plugin\dom_processor\data_processor\ParagraphsEditorDecorator
   * @see \Drupal\paragraphs_editor\Plugin\dom_processor\data_processor\ParagraphsEditorExtractor
   *
   * @return \Drupal\dom_processor\DomProcessor\DomProcessorResultInterface
   *   See the ParagraphsEditorDecorator and ParagraphsEditorExtractor DOM
   *   Processor plugins for more information.
   */
  protected function process($variant, FieldItemListInterface $items, FormStateInterface $form_state, $format = NULL, $markup = NULL, $context_id = NULL) {
    if (!$items->isEmpty()) {
      if (!isset($markup)) {
        $markup = $items->entity->getMarkup();
      }

      if (!isset($format)) {
        $format = $items->entity->getFormat();
      }
    }

    if (empty($format)) {
      $format = $this->getSetting('filter_format');
    }

    // Ensure that we can get an entity to savethe updates to.
    $form_object = $form_state->getFormObject();
    if (!$form_object instanceof EntityFormInterface) {
      throw new \Exception('Could not locate entity to save changes to in paragraphs editor widget.');
    }

    // Check revisioning status.
    $entity = $form_object->getEntity();
    $new_revision = FALSE;
    if ($entity instanceof RevisionableInterface) {
      if ($entity->isNewRevision()) {
        $new_revision = TRUE;
      }
      elseif ($entity->getEntityType()->hasKey('revision') && $form_state->getValue('revision')) {
        $new_revision = TRUE;
      }
    }

    return $this->domProcessor->process($markup, 'paragraphs_editor', $variant, [
      'field' => [
        'items' => $items,
        'context_id' => $context_id,
        'is_mutable' => TRUE,
      ],
      'owner' => [
        'entity' => $entity,
        'new_revision' => $new_revision,
      ],
      'langcode' => $form_state->get('langcode'),
      'settings' => $this->getSettings(),
      'filter_format' => $format,
    ]);
  }

  /**
   * Safely gets the field config associated with this widget.
   *
   * @return \Drupal\Core\Field\FieldConfigInterface
   *   The field config object.
   */
  protected function getFieldConfig() {
    return TypeUtility::ensureFieldConfig($this->fieldDefinition);
  }

  /**
   * Determines whether the widget should be hidden.
   *
   * @param \Drupal\Core\Field\FieldItemListInterface $items
   *   The field items being edited.
   * @param \Drupal\Core\Form\FormStateInterface $form_state
   *   The form state of the form the widget is being added to.
   *
   * @return bool
   *   TRUE if the widget should be added to the form, FALSE otherwise.
   */
  protected function shouldHide(FieldItemListInterface $items, FormStateInterface $form_state) {
    return $form_state->getFormObject() instanceof ParagraphsEditorFormInterface
      || $form_state->getFormObject()->getFormId() == 'field_config_edit_form';
  }

}
